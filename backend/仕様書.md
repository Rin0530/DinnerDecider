# Goバックエンド 技術仕様書

## 1. はじめに

「冷蔵庫の中身をMySQLに記録し、GPTに今日の夕飯を考えてもらうWebアプリ」のバックエンドをGo言語で構築するにあたり、保守性、拡張性、そしてパフォーマンスを重視した設計を提案します。

具体的には、以下の点を考慮した構成です。

*   **関心の分離**: ビジネスロジック、データアクセス、Webリクエストの処理を明確に分離し、コードの見通しを良くします。
*   **テスト容易性**: 各コンポーネントが独立してテストできるようにします。
*   **拡張性**: 将来的に機能追加（例：ユーザー認証、買い物リスト作成）がしやすい構造にします。

## 2. アーキテクチャ設計

バックエンドのアーキテクチャとして、**クリーンアーキテクチャ**の採用を強く推奨します。これにより、システムの各部分が疎結合になり、変更に強いアプリケーションを構築できます。

### 2.1. 全体構成

アプリケーションは以下のコンポーネントで構成されます。

```
+-----------------+      +-------------------------------------------------+      +-----------------+
|                 |      |                 Go Backend                      |      |                 |
|   Client        |----->|  +---------+   +---------+   +---------------+  |----->|   MySQL         |
| (Web/Mobile)    |      |  | Handler |-->| Usecase |-->|  Repository   |  |      | (冷蔵庫の中身)  |
|                 |      |  +---------+   +---------+   +---------------+  |      |                 |
+-----------------+      |      ^             |                            |      +-----------------+
                         |      |             |                            |      
                         |      |             v                            |      +-----------------+
                         |      |      +----------------+                   |      |                 |
                         |      +------|  External API  |------------------------->|  Ollama (LLM)   |
                         |             | (LLM Service)  |                   |      | (献立提案)      |
                         |             +----------------+                   |      |                 |
                         +-------------------------------------------------+      +-----------------+
```

*   **Handler (Controller)**: HTTPリクエストを受け取り、レスポンスを返します。リクエスト内容を解釈し、Usecaseを呼び出します。
*   **Usecase (Service)**: アプリケーションのビジネスロジックを担当します。複数のリポジトリや外部サービスを組み合わせて、一連の処理を実行します。（例：「冷蔵庫の食材リストを取得し、GPTに献立を提案させる」）
*   **Repository**: データベース（MySQL）とのやり取りを抽象化します。食材のCRUD操作などを担当します。
*   **External API**: OpenAI APIのような外部サービスとの通信を担当します。

### 2.2. ディレクトリ構成案

クリーンアーキテクチャに基づいた、分かりやすいディレクトリ構成の例です。

```
refrigerator-api/
├── cmd/
│   └── api/
│       └── main.go          # アプリケーションのエントリポイント
├── internal/
│   ├── handler/             # HTTPハンドラ
│   │   ├── handler.go
│   │   ├── ingredient.go
│   │   └── recipe.go
│   ├── usecase/             # ビジネスロジック
│   │   ├── usecase.go
│   │   ├── ingredient.go
│   │   └── recipe.go
│   ├── repository/          # データアクセス層
│   │   ├── repository.go
│   │   ├── ingredient_mysql.go
│   │   └── models.go        # DBモデル
│   ├── service/             # 外部サービス連携
│   │   └── openai.go
│   └── domain/              # ドメインモデル (UsecaseやRepositoryで使う構造体)
│       ├── ingredient.go
│       └── recipe.go
├── pkg/                     # 共有ライブラリ (config, loggerなど)
│   ├── config/
│   └── logger/
├── go.mod
├── go.sum
└── config.yml               # 設定ファイル
```

## 3. 技術スタックの選定

Goのエコシステムから、実績があり生産性の高いライブラリを選定しました。

| 目的 | ライブラリ | 選定理由 |
| :--- | :--- | :--- |
| **Webフレームワーク** | Gin | 高速で、API開発に必要な機能が揃っています。ドキュメントも豊富で学習しやすく、デファクトスタンダードの一つです。 |
| **DBアクセス** | sqlx | 標準の`database/sql`を拡張したライブラリです。SQLを直接書きつつ、結果を構造体にマッピングするのが容易で、パフォーマンスと生産性のバランスが取れています。 |
| **MySQLドライバ** | go-sql-driver/mysql | GoのMySQLドライバとして最も広く使われており、信頼性が高いです。 |
| **設定管理** | Viper | ファイル（YAML, JSON等）、環境変数、リモートなど、多様なソースから設定を読み込めるため、開発環境と本番環境で設定を切り替えやすいです。 |
| **OpenAI APIクライアント** | sashabaranov/go-openai | OpenAI APIのGoクライアントとして広く使われており、メンテナンスも活発です。 |
| **バリデーション** | go-playground/validator | 構造体のタグベースで簡単にバリデーションルールを定義できます。Ginとの連携も容易です。 |
| **APIドキュメンテーション** | Swag + gin-swagger | GoコードのコメントからSwagger/OpenAPIドキュメントを自動生成し、GinアプリケーションにSwagger UIを提供します。APIの可視性と開発効率を向上させます。 |

## 4. API設計案

クライアントと連携するためのAPIエンドポイントを設計します。

| メソッド | エンドポイント | 説明 |
| :--- | :--- | :--- |
| `GET` | `/ingredients` | 冷蔵庫に入っている食材の一覧を取得する。 |
| `POST` | `/ingredients` | 新しい食材を冷蔵庫に追加する。 |
| `PUT` | `/ingredients/:id` | 特定の食材の情報（数量など）を更新する。 |
| `DELETE` | `/ingredients/:id` | 特定の食材を削除する。 |
| `POST` | `/recipes/suggestion` | 現在の食材リストを元に、夕食の献立をGPTに提案してもらう。 |

### 4.1. 食材登録 (`POST /ingredients`)

冷蔵庫に新しい食材を登録します。

**リクエストボディ**

```json
{
  "name": "にんじん",
  "quantity": "2本",
  "expiration_date": "2023-12-31"
}
```

*   `name` (string, 必須): 食材名
*   `quantity` (string, 任意): 数量
*   `expiration_date` (string, 任意): 賞味期限 (YYYY-MM-DD形式)

**成功レスポンス (201 Created)**

登録された食材の情報が返却されます。

```json
{
  "id": 1,
  "name": "にんじん",
  "quantity": "2本",
  "expiration_date": "2023-12-31"
}
```

## 5. データベース設計案 (MySQL)

シンプルな食材管理テーブルを設計します。

**`ingredients` テーブル**

| カラム名 | 型 | 説明 |
| :--- | :--- | :--- |
| `id` | `BIGINT AUTO_INCREMENT PRIMARY KEY` | 一意なID |
| `name` | `VARCHAR(255) NOT NULL` | 食材名（例：にんじん、豚バラ肉） |
| `quantity` | `VARCHAR(100)` | 数量（例：2本, 200g） |
| `expiration_date` | `DATE` | 賞味期限（NULL許容） |
| `created_at` | `TIMESTAMP DEFAULT CURRENT_TIMESTAMP` | 作成日時 |
| `updated_at` | `TIMESTAMP DEFAULT CURRENT_TIMESTAMP ON UPDATE CURRENT_TIMESTAMP` | 更新日時 |

## 6. GPT連携のポイント

献立を提案してもらう際のプロンプト設計が重要になります。

**Usecase (`/recipes/suggestion`の処理) の流れ:**

1.  `Repository` を使って、MySQLから現在の食材リストを取得します。
2.  取得した食材リストを、GPTが理解しやすいテキスト形式に整形します。
    *   例: `にんじん(2本), 豚バラ肉(200g), 玉ねぎ(1個), 豆腐(1丁)`
3.  整形した食材リストを埋め込んだプロンプトを作成します。
4.  `OpenAI Service` を呼び出し、GPTに献立を問い合わせます。
5.  GPTからの返却された献立（JSON形式で返してもらうと後続処理が楽です）をパースし、クライアントに返却します。

**プロンプトの例:**

```text
あなたはプロの料理人です。以下の食材を使って作れる、美味しくて簡単な夕食の献立を3つ提案してください。
それぞれの献立には、料理名、簡単な作り方、そして不足している食材（もしあれば）を記載してください。
回答は必ずJSON形式で、以下のフォーマットに従ってください。

{
  "suggestions": [
    {
      "name": "料理名",
      "steps": [
        "手順1",
        "手順2"
      ],
      "missing_items": ["不足している食材1", "不足している食材2"]
    }
  ]
}

# 利用可能な食材
- にんじん(2本)
- 豚バラ肉(200g)
- 玉ねぎ(1個)
- 豆腐(1丁)
```

## まとめ

この設計は、Go言語の強みであるシンプルさとパフォーマンスを活かしつつ、将来の拡張にも耐えうる堅牢なバックエンドの基礎となります。まずは`internal/repository`と`internal/handler`から実装を始め、徐々に`usecase`でビジネスロジックを組み立てていく進め方が良いでしょう。